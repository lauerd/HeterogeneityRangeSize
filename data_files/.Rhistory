Map <- crop(Map, Africa) # If the CRS of the map is the same as that of "Africa", crop it to "Africa"'s extent.
Map <- mask(Map, Africa) # Clip the cropped map such that it encompasses only the shape of "Africa".
# Map <- raster::aggregate(Map, 5) # Potentially aggregate the map to a coarser resolution.
Hab <- grepl('Hab', Map_var) # Indicate if the map refers to habitat heterogeneity or not.
Map <- Map * ifelse(Hab, 0.0001, 1) # For habitat heterogeneity, multiply by 0.0001 based on EarthEnv metadata.
Transform <- '(ln)' # OR "(Box-Cox)", depending upon which transformation of the map's values will be performed.
if (Transform == '(Box-Cox)') { values(Map)[!is.na(values(Map))] <- BoxCox(values(Map)[!is.na(values(Map))],
lambda = BoxCoxLambda(values(Map)[!is.na(values(Map))], method = 'guerrero', lower = -5, upper = 5)) }
if (Transform == '(ln)') { Map <- log(Map); values(Map)[is.infinite(values(Map))] <- NA } # Remove infinite values.
Col_no <- 255 # Choose the number of colors that will be used in plotting the map.
Cols <- colorRampPalette(c('peachpuff', ifelse(Hab, 'cadetblue4', 'brown4')))(Col_no) # Choose color scheme.
Breaks <- unname(quantile(values(Map), seq(0, 1, length.out = Col_no + 1), na.rm = TRUE)) # Breaks for map colors.
for (Val in which(duplicated(Breaks))) { Breaks[Val] <- Breaks[Val-1] + 0.000001 } # Prevent duplicate breaks.
# Plot the map, using the settings above:
par(mar = c(2.1,2.1,1,1)) # Adjust plot margins.
plot(Map, axes = TRUE, box = TRUE, cex.axis = 3.5, mgp = c(3,2,0), # Plot map. Maybe remove axes and box.
col = Cols, breaks = Breaks, # Set plot colors, and scale them based on distribution of "Map" values.
# legend.args = list(text = ifelse(Hab, paste('Coef Var EVI', Transform), paste('TRI', Transform)),
#   side = 4, line = 5, font = 2, cex = 2), # Format legend title.
axis.args = list(cex.axis = 3.5, at = c(minValue(Map), maxValue(Map)), labels=c('Few\nHabitats','Many\nHabitats')))
}; rm(Hab, Transform, Col_no, Breaks, Val) # "c('Few\nHabitats','Many\nHabitats')" or "c('Smooth', 'Rugged')".
# Map <- shapefile('./official/wwf_terr_ecos.shp'); Map_var <- 'Biomes' # If plotting the biomes/ecoregions in Africa.
Map <- raster('cv_01_05_1km_uint16.tif'); Map_var <- 'Hab_Xkm' # If plotting habitat heterogeneity at X-km res.
if (grepl('Raster', class(Map))) { # If the map is a raster...
# Process the map and determine its settings for plotting it:
Map <- crop(Map, Africa) # If the CRS of the map is the same as that of "Africa", crop it to "Africa"'s extent.
Map <- mask(Map, Africa) # Clip the cropped map such that it encompasses only the shape of "Africa".
# Map <- raster::aggregate(Map, 5) # Potentially aggregate the map to a coarser resolution.
Hab <- grepl('Hab', Map_var) # Indicate if the map refers to habitat heterogeneity or not.
Map <- Map * ifelse(Hab, 0.0001, 1) # For habitat heterogeneity, multiply by 0.0001 based on EarthEnv metadata.
Transform <- '(ln)' # OR "(Box-Cox)", depending upon which transformation of the map's values will be performed.
if (Transform == '(Box-Cox)') { values(Map)[!is.na(values(Map))] <- BoxCox(values(Map)[!is.na(values(Map))],
lambda = BoxCoxLambda(values(Map)[!is.na(values(Map))], method = 'guerrero', lower = -5, upper = 5)) }
if (Transform == '(ln)') { Map <- log(Map); values(Map)[is.infinite(values(Map))] <- NA } # Remove infinite values.
Col_no <- 255 # Choose the number of colors that will be used in plotting the map.
Cols <- colorRampPalette(c('peachpuff', ifelse(Hab, 'cadetblue4', 'brown4')))(Col_no) # Choose color scheme.
Breaks <- unname(quantile(values(Map), seq(0, 1, length.out = Col_no + 1), na.rm = TRUE)) # Breaks for map colors.
for (Val in which(duplicated(Breaks))) { Breaks[Val] <- Breaks[Val-1] + 0.000001 } # Prevent duplicate breaks.
# Plot the map, using the settings above:
par(mar = c(1.7,1.7,1,1)) # Adjust plot margins.
plot(Map, axes = TRUE, box = TRUE, cex.axis = 3.5, mgp = c(3,2,0), # Plot map. Maybe remove axes and box.
col = Cols, breaks = Breaks, # Set plot colors, and scale them based on distribution of "Map" values.
# legend.args = list(text = ifelse(Hab, paste('Coef Var EVI', Transform), paste('TRI', Transform)),
#   side = 4, line = 5, font = 2, cex = 2), # Format legend title.
axis.args = list(cex.axis = 3.5, at = c(minValue(Map), maxValue(Map)), labels=c('Few\nHabitats','Many\nHabitats')))
}; rm(Hab, Transform, Col_no, Breaks, Val) # "c('Few\nHabitats','Many\nHabitats')" or "c('Smooth', 'Rugged')".
# Map <- shapefile('./official/wwf_terr_ecos.shp'); Map_var <- 'Biomes' # If plotting the biomes/ecoregions in Africa.
Map <- raster('cv_01_05_1km_uint16.tif'); Map_var <- 'Hab_Xkm' # If plotting habitat heterogeneity at X-km res.
if (grepl('Raster', class(Map))) { # If the map is a raster...
# Process the map and determine its settings for plotting it:
Map <- crop(Map, Africa) # If the CRS of the map is the same as that of "Africa", crop it to "Africa"'s extent.
Map <- mask(Map, Africa) # Clip the cropped map such that it encompasses only the shape of "Africa".
# Map <- raster::aggregate(Map, 5) # Potentially aggregate the map to a coarser resolution.
Hab <- grepl('Hab', Map_var) # Indicate if the map refers to habitat heterogeneity or not.
Map <- Map * ifelse(Hab, 0.0001, 1) # For habitat heterogeneity, multiply by 0.0001 based on EarthEnv metadata.
Transform <- '(ln)' # OR "(Box-Cox)", depending upon which transformation of the map's values will be performed.
if (Transform == '(Box-Cox)') { values(Map)[!is.na(values(Map))] <- BoxCox(values(Map)[!is.na(values(Map))],
lambda = BoxCoxLambda(values(Map)[!is.na(values(Map))], method = 'guerrero', lower = -5, upper = 5)) }
if (Transform == '(ln)') { Map <- log(Map); values(Map)[is.infinite(values(Map))] <- NA } # Remove infinite values.
Col_no <- 255 # Choose the number of colors that will be used in plotting the map.
Cols <- colorRampPalette(c('peachpuff', ifelse(Hab, 'cadetblue4', 'brown4')))(Col_no) # Choose color scheme.
Breaks <- unname(quantile(values(Map), seq(0, 1, length.out = Col_no + 1), na.rm = TRUE)) # Breaks for map colors.
for (Val in which(duplicated(Breaks))) { Breaks[Val] <- Breaks[Val-1] + 0.000001 } # Prevent duplicate breaks.
# Plot the map, using the settings above:
par(mar = c(1.2,1.2,1,1)) # Adjust plot margins.
plot(Map, axes = TRUE, box = TRUE, cex.axis = 3.5, mgp = c(3,2,0), # Plot map. Maybe remove axes and box.
col = Cols, breaks = Breaks, # Set plot colors, and scale them based on distribution of "Map" values.
# legend.args = list(text = ifelse(Hab, paste('Coef Var EVI', Transform), paste('TRI', Transform)),
#   side = 4, line = 5, font = 2, cex = 2), # Format legend title.
axis.args = list(cex.axis = 3.5, at = c(minValue(Map), maxValue(Map)), labels=c('Few\nHabitats','Many\nHabitats')))
}; rm(Hab, Transform, Col_no, Breaks, Val) # "c('Few\nHabitats','Many\nHabitats')" or "c('Smooth', 'Rugged')".
# Map <- shapefile('./official/wwf_terr_ecos.shp'); Map_var <- 'Biomes' # If plotting the biomes/ecoregions in Africa.
Map <- raster('cv_01_05_1km_uint16.tif'); Map_var <- 'Hab_Xkm' # If plotting habitat heterogeneity at X-km res.
if (grepl('Raster', class(Map))) { # If the map is a raster...
# Process the map and determine its settings for plotting it:
Map <- crop(Map, Africa) # If the CRS of the map is the same as that of "Africa", crop it to "Africa"'s extent.
Map <- mask(Map, Africa) # Clip the cropped map such that it encompasses only the shape of "Africa".
# Map <- raster::aggregate(Map, 5) # Potentially aggregate the map to a coarser resolution.
Hab <- grepl('Hab', Map_var) # Indicate if the map refers to habitat heterogeneity or not.
Map <- Map * ifelse(Hab, 0.0001, 1) # For habitat heterogeneity, multiply by 0.0001 based on EarthEnv metadata.
Transform <- '(ln)' # OR "(Box-Cox)", depending upon which transformation of the map's values will be performed.
if (Transform == '(Box-Cox)') { values(Map)[!is.na(values(Map))] <- BoxCox(values(Map)[!is.na(values(Map))],
lambda = BoxCoxLambda(values(Map)[!is.na(values(Map))], method = 'guerrero', lower = -5, upper = 5)) }
if (Transform == '(ln)') { Map <- log(Map); values(Map)[is.infinite(values(Map))] <- NA } # Remove infinite values.
Col_no <- 255 # Choose the number of colors that will be used in plotting the map.
Cols <- colorRampPalette(c('peachpuff', ifelse(Hab, 'cadetblue4', 'brown4')))(Col_no) # Choose color scheme.
Breaks <- unname(quantile(values(Map), seq(0, 1, length.out = Col_no + 1), na.rm = TRUE)) # Breaks for map colors.
for (Val in which(duplicated(Breaks))) { Breaks[Val] <- Breaks[Val-1] + 0.000001 } # Prevent duplicate breaks.
# Plot the map, using the settings above:
par(mar = c(1.6,1.3,1,1)) # Adjust plot margins.
plot(Map, axes = TRUE, box = TRUE, cex.axis = 3.5, mgp = c(3,2,0), # Plot map. Maybe remove axes and box.
col = Cols, breaks = Breaks, # Set plot colors, and scale them based on distribution of "Map" values.
# legend.args = list(text = ifelse(Hab, paste('Coef Var EVI', Transform), paste('TRI', Transform)),
#   side = 4, line = 5, font = 2, cex = 2), # Format legend title.
axis.args = list(cex.axis = 3.5, at = c(minValue(Map), maxValue(Map)), labels=c('Few\nHabitats','Many\nHabitats')))
}; rm(Hab, Transform, Col_no, Breaks, Val) # "c('Few\nHabitats','Many\nHabitats')" or "c('Smooth', 'Rugged')".
# Map <- shapefile('./official/wwf_terr_ecos.shp'); Map_var <- 'Biomes' # If plotting the biomes/ecoregions in Africa.
# Map <- raster('cv_01_05_1km_uint16.tif'); Map_var <- 'Hab_Xkm' # If plotting habitat heterogeneity at X-km res.
Map <- raster('tri_1KMmn_GMTEDmd.tif'); Map_var <- 'Topo_Xkm' # If plotting topographic heterogeneity at X-km res.
if (grepl('Raster', class(Map))) { # If the map is a raster...
# Process the map and determine its settings for plotting it:
Map <- crop(Map, Africa) # If the CRS of the map is the same as that of "Africa", crop it to "Africa"'s extent.
Map <- mask(Map, Africa) # Clip the cropped map such that it encompasses only the shape of "Africa".
# Map <- raster::aggregate(Map, 5) # Potentially aggregate the map to a coarser resolution.
Hab <- grepl('Hab', Map_var) # Indicate if the map refers to habitat heterogeneity or not.
Map <- Map * ifelse(Hab, 0.0001, 1) # For habitat heterogeneity, multiply by 0.0001 based on EarthEnv metadata.
Transform <- '(ln)' # OR "(Box-Cox)", depending upon which transformation of the map's values will be performed.
if (Transform == '(Box-Cox)') { values(Map)[!is.na(values(Map))] <- BoxCox(values(Map)[!is.na(values(Map))],
lambda = BoxCoxLambda(values(Map)[!is.na(values(Map))], method = 'guerrero', lower = -5, upper = 5)) }
if (Transform == '(ln)') { Map <- log(Map); values(Map)[is.infinite(values(Map))] <- NA } # Remove infinite values.
Col_no <- 255 # Choose the number of colors that will be used in plotting the map.
Cols <- colorRampPalette(c('peachpuff', ifelse(Hab, 'cadetblue4', 'brown4')))(Col_no) # Choose color scheme.
Breaks <- unname(quantile(values(Map), seq(0, 1, length.out = Col_no + 1), na.rm = TRUE)) # Breaks for map colors.
for (Val in which(duplicated(Breaks))) { Breaks[Val] <- Breaks[Val-1] + 0.000001 } # Prevent duplicate breaks.
# Plot the map, using the settings above:
par(mar = c(1.6,1.3,1,1)) # Adjust plot margins.
plot(Map, axes = TRUE, box = TRUE, cex.axis = 3.5, mgp = c(3,2,0), # Plot map. Maybe remove axes and box.
col = Cols, breaks = Breaks, # Set plot colors, and scale them based on distribution of "Map" values.
# legend.args = list(text = ifelse(Hab, paste('Coef Var EVI', Transform), paste('TRI', Transform)),
#   side = 4, line = 5, font = 2, cex = 2), # Format legend title.
axis.args = list(cex.axis = 3.5, at = c(minValue(Map), maxValue(Map)), labels=c('Smooth', 'Rugged')))
}; rm(Hab, Transform, Col_no, Breaks, Val) # "c('Few\nHabitats','Many\nHabitats')" or "c('Smooth', 'Rugged')".
# Map <- shapefile('./official/wwf_terr_ecos.shp'); Map_var <- 'Biomes' # If plotting the biomes/ecoregions in Africa.
# Map <- raster('cv_01_05_1km_uint16.tif'); Map_var <- 'Hab_Xkm' # If plotting habitat heterogeneity at X-km res.
Map <- raster('tri_1KMmn_GMTEDmd.tif'); Map_var <- 'Topo_Xkm' # If plotting topographic heterogeneity at X-km res.
if (grepl('Raster', class(Map))) { # If the map is a raster...
# Process the map and determine its settings for plotting it:
Map <- crop(Map, Africa) # If the CRS of the map is the same as that of "Africa", crop it to "Africa"'s extent.
Map <- mask(Map, Africa) # Clip the cropped map such that it encompasses only the shape of "Africa".
Map <- raster::aggregate(Map, 5) # Potentially aggregate the map to a coarser resolution.
Hab <- grepl('Hab', Map_var) # Indicate if the map refers to habitat heterogeneity or not.
Map <- Map * ifelse(Hab, 0.0001, 1) # For habitat heterogeneity, multiply by 0.0001 based on EarthEnv metadata.
Transform <- '(ln)' # OR "(Box-Cox)", depending upon which transformation of the map's values will be performed.
if (Transform == '(Box-Cox)') { values(Map)[!is.na(values(Map))] <- BoxCox(values(Map)[!is.na(values(Map))],
lambda = BoxCoxLambda(values(Map)[!is.na(values(Map))], method = 'guerrero', lower = -5, upper = 5)) }
if (Transform == '(ln)') { Map <- log(Map); values(Map)[is.infinite(values(Map))] <- NA } # Remove infinite values.
Col_no <- 255 # Choose the number of colors that will be used in plotting the map.
Cols <- colorRampPalette(c('peachpuff', ifelse(Hab, 'cadetblue4', 'brown4')))(Col_no) # Choose color scheme.
Breaks <- unname(quantile(values(Map), seq(0, 1, length.out = Col_no + 1), na.rm = TRUE)) # Breaks for map colors.
for (Val in which(duplicated(Breaks))) { Breaks[Val] <- Breaks[Val-1] + 0.000001 } # Prevent duplicate breaks.
# Plot the map, using the settings above:
par(mar = c(1.6,1.3,1,1)) # Adjust plot margins.
plot(Map, axes = TRUE, box = TRUE, cex.axis = 3.5, mgp = c(3,2,0), # Plot map. Maybe remove axes and box.
col = Cols, breaks = Breaks, # Set plot colors, and scale them based on distribution of "Map" values.
# legend.args = list(text = ifelse(Hab, paste('Coef Var EVI', Transform), paste('TRI', Transform)),
#   side = 4, line = 5, font = 2, cex = 2), # Format legend title.
axis.args = list(cex.axis = 3.5, at = c(minValue(Map), maxValue(Map)), labels=c('Smooth', 'Rugged')))
}; rm(Hab, Transform, Col_no, Breaks, Val) # "c('Few\nHabitats','Many\nHabitats')" or "c('Smooth', 'Rugged')".
# Map <- shapefile('./official/wwf_terr_ecos.shp'); Map_var <- 'Biomes' # If plotting the biomes/ecoregions in Africa.
# Map <- raster('cv_01_05_1km_uint16.tif'); Map_var <- 'Hab_Xkm' # If plotting habitat heterogeneity at X-km res.
Map <- raster('tri_1KMmn_GMTEDmd.tif'); Map_var <- 'Topo_Xkm' # If plotting topographic heterogeneity at X-km res.
if (grepl('Raster', class(Map))) { # If the map is a raster...
# Process the map and determine its settings for plotting it:
Map <- crop(Map, Africa) # If the CRS of the map is the same as that of "Africa", crop it to "Africa"'s extent.
Map <- mask(Map, Africa) # Clip the cropped map such that it encompasses only the shape of "Africa".
Map <- raster::aggregate(Map, 50) # Potentially aggregate the map to a coarser resolution.
Hab <- grepl('Hab', Map_var) # Indicate if the map refers to habitat heterogeneity or not.
Map <- Map * ifelse(Hab, 0.0001, 1) # For habitat heterogeneity, multiply by 0.0001 based on EarthEnv metadata.
Transform <- '(ln)' # OR "(Box-Cox)", depending upon which transformation of the map's values will be performed.
if (Transform == '(Box-Cox)') { values(Map)[!is.na(values(Map))] <- BoxCox(values(Map)[!is.na(values(Map))],
lambda = BoxCoxLambda(values(Map)[!is.na(values(Map))], method = 'guerrero', lower = -5, upper = 5)) }
if (Transform == '(ln)') { Map <- log(Map); values(Map)[is.infinite(values(Map))] <- NA } # Remove infinite values.
Col_no <- 255 # Choose the number of colors that will be used in plotting the map.
Cols <- colorRampPalette(c('peachpuff', ifelse(Hab, 'cadetblue4', 'brown4')))(Col_no) # Choose color scheme.
Breaks <- unname(quantile(values(Map), seq(0, 1, length.out = Col_no + 1), na.rm = TRUE)) # Breaks for map colors.
for (Val in which(duplicated(Breaks))) { Breaks[Val] <- Breaks[Val-1] + 0.000001 } # Prevent duplicate breaks.
# Plot the map, using the settings above:
par(mar = c(1.6,1.3,1,1)) # Adjust plot margins.
plot(Map, axes = TRUE, box = TRUE, cex.axis = 3.5, mgp = c(3,2,0), # Plot map. Maybe remove axes and box.
col = Cols, breaks = Breaks, # Set plot colors, and scale them based on distribution of "Map" values.
# legend.args = list(text = ifelse(Hab, paste('Coef Var EVI', Transform), paste('TRI', Transform)),
#   side = 4, line = 5, font = 2, cex = 2), # Format legend title.
axis.args = list(cex.axis = 3.5, at = c(minValue(Map), maxValue(Map)), labels=c('Smooth', 'Rugged')))
}; rm(Hab, Transform, Col_no, Breaks, Val) # "c('Few\nHabitats','Many\nHabitats')" or "c('Smooth', 'Rugged')".
# Map <- shapefile('./official/wwf_terr_ecos.shp'); Map_var <- 'Biomes' # If plotting the biomes/ecoregions in Africa.
Map <- raster('cv_01_05_1km_uint16.tif'); Map_var <- 'Hab_Xkm' # If plotting habitat heterogeneity at X-km res.
if (grepl('Raster', class(Map))) { # If the map is a raster...
# Process the map and determine its settings for plotting it:
Map <- crop(Map, Africa) # If the CRS of the map is the same as that of "Africa", crop it to "Africa"'s extent.
Map <- mask(Map, Africa) # Clip the cropped map such that it encompasses only the shape of "Africa".
Map <- raster::aggregate(Map, 50) # Potentially aggregate the map to a coarser resolution.
Hab <- grepl('Hab', Map_var) # Indicate if the map refers to habitat heterogeneity or not.
Map <- Map * ifelse(Hab, 0.0001, 1) # For habitat heterogeneity, multiply by 0.0001 based on EarthEnv metadata.
Transform <- '(ln)' # OR "(Box-Cox)", depending upon which transformation of the map's values will be performed.
if (Transform == '(Box-Cox)') { values(Map)[!is.na(values(Map))] <- BoxCox(values(Map)[!is.na(values(Map))],
lambda = BoxCoxLambda(values(Map)[!is.na(values(Map))], method = 'guerrero', lower = -5, upper = 5)) }
if (Transform == '(ln)') { Map <- log(Map); values(Map)[is.infinite(values(Map))] <- NA } # Remove infinite values.
Col_no <- 255 # Choose the number of colors that will be used in plotting the map.
Cols <- colorRampPalette(c('peachpuff', ifelse(Hab, 'cadetblue4', 'brown4')))(Col_no) # Choose color scheme.
Breaks <- unname(quantile(values(Map), seq(0, 1, length.out = Col_no + 1), na.rm = TRUE)) # Breaks for map colors.
for (Val in which(duplicated(Breaks))) { Breaks[Val] <- Breaks[Val-1] + 0.000001 } # Prevent duplicate breaks.
# Plot the map, using the settings above:
par(mar = c(1.6,1.3,1,1)) # Adjust plot margins.
plot(Map, axes = TRUE, box = TRUE, cex.axis = 3.5, mgp = c(3,2,0), # Plot map. Maybe remove axes and box.
col = Cols, breaks = Breaks, # Set plot colors, and scale them based on distribution of "Map" values.
# legend.args = list(text = ifelse(Hab, paste('Coef Var EVI', Transform), paste('TRI', Transform)),
#   side = 4, line = 5, font = 2, cex = 2), # Format legend title.
axis.args = list(cex.axis = 3.5, at = c(minValue(Map), maxValue(Map)), labels=c('Few\nHabitats','Many\nHabitats')))
}; rm(Hab, Transform, Col_no, Breaks, Val) # "c('Few\nHabitats','Many\nHabitats')" or "c('Smooth', 'Rugged')".
# Map <- shapefile('./official/wwf_terr_ecos.shp'); Map_var <- 'Biomes' # If plotting the biomes/ecoregions in Africa.
Map <- raster('cv_01_05_1km_uint16.tif'); Map_var <- 'Hab_Xkm' # If plotting habitat heterogeneity at X-km res.
if (grepl('Raster', class(Map))) { # If the map is a raster...
# Process the map and determine its settings for plotting it:
Map <- crop(Map, Africa) # If the CRS of the map is the same as that of "Africa", crop it to "Africa"'s extent.
Map <- mask(Map, Africa) # Clip the cropped map such that it encompasses only the shape of "Africa".
Map <- raster::aggregate(Map, 5) # Potentially aggregate the map to a coarser resolution.
Hab <- grepl('Hab', Map_var) # Indicate if the map refers to habitat heterogeneity or not.
Map <- Map * ifelse(Hab, 0.0001, 1) # For habitat heterogeneity, multiply by 0.0001 based on EarthEnv metadata.
Transform <- '(ln)' # OR "(Box-Cox)", depending upon which transformation of the map's values will be performed.
if (Transform == '(Box-Cox)') { values(Map)[!is.na(values(Map))] <- BoxCox(values(Map)[!is.na(values(Map))],
lambda = BoxCoxLambda(values(Map)[!is.na(values(Map))], method = 'guerrero', lower = -5, upper = 5)) }
if (Transform == '(ln)') { Map <- log(Map); values(Map)[is.infinite(values(Map))] <- NA } # Remove infinite values.
Col_no <- 255 # Choose the number of colors that will be used in plotting the map.
Cols <- colorRampPalette(c('peachpuff', ifelse(Hab, 'cadetblue4', 'brown4')))(Col_no) # Choose color scheme.
Breaks <- unname(quantile(values(Map), seq(0, 1, length.out = Col_no + 1), na.rm = TRUE)) # Breaks for map colors.
for (Val in which(duplicated(Breaks))) { Breaks[Val] <- Breaks[Val-1] + 0.000001 } # Prevent duplicate breaks.
# Plot the map, using the settings above:
par(mar = c(1.6,1.3,1,1)) # Adjust plot margins.
plot(Map, axes = TRUE, box = TRUE, cex.axis = 3.5, mgp = c(3,2,0), # Plot map. Maybe remove axes and box.
col = Cols, breaks = Breaks, # Set plot colors, and scale them based on distribution of "Map" values.
# legend.args = list(text = ifelse(Hab, paste('Coef Var EVI', Transform), paste('TRI', Transform)),
#   side = 4, line = 5, font = 2, cex = 2), # Format legend title.
axis.args = list(cex.axis = 3.5, at = c(minValue(Map), maxValue(Map)), labels=c('Few\nHabitats','Many\nHabitats')))
}; rm(Hab, Transform, Col_no, Breaks, Val) # "c('Few\nHabitats','Many\nHabitats')" or "c('Smooth', 'Rugged')".
rm(Map, Map_var)
Map_hab <- raster('cv_01_05_1km_uint16.tif') # Habitat heterogeneity map at 1-km resolution.
Map_topo <- raster('tri_1KMmn_GMTEDmd.tif') # Topographic heterogeneity map at 1-km resolution.
for (Het_map in c('Map_hab', 'Map_topo')) { # For each map...
Map <- eval(parse(text = Het_map)) # Create a variable, "Map", the is equal to the current map.
Map <- crop(Map, Africa) # Crop the map to the extent of "Africa".
Map <- mask(Map, Africa) # Mask the cropped map to the shape of "Africa".
Map <- Map * ifelse(grepl('hab', Het_map), 0.0001, 1) # Multiply the "hab" map by 0.0001 based on EarthEnv metadata.
Map <- log(Map); values(Map)[is.infinite(values(Map))] <- NA # Log-transform map values and remove resultant Inf.
Map <- raster::aggregate(Map, 5) # Potentially aggregate map to a coarser resolution.
assign(Het_map, Map) }; rm(Het_map, Map) # Update the map to be equal to "Map", now that "Map" is processed.
Map_valindices <- which(!is.na(values(Map_hab)) & !is.na(values(Map_topo))) # Map pixel indices with paired values.
library(spatialRF) # For assessing spatial autocorrelation and using the "moran" function.
Map_valindices_sampler <- function(Num) { # Function to sample spatially-unautocorrelated pixels from "Map_valindices".
Samp <- sample(Map_valindices, Num) # Randomly sample "Num" raster pixel indices from "Map_valindices".
Coordinates <- xyFromCell(Map_hab, cell = Samp) # Get the lon/lat coordinates of the raster pixels in the sample.
Distance_matrix <- pointDistance(Coordinates, lonlat = TRUE) # Produce matrix of distances between the sample pixels.
Distance_matrix[upper.tri(Distance_matrix)] <- t(Distance_matrix)[upper.tri(Distance_matrix)] # Make matrix full.
Moran_hab <- moran(x = Map_hab[Samp], distance.matrix = Distance_matrix, verbose = FALSE) # Moran's I for hab.
Moran_topo <- moran(x = Map_topo[Samp], distance.matrix = Distance_matrix, verbose = FALSE) # Moran's I for topo.
if (abs(Moran_hab$test$moran.i) > 0.1 | abs(Moran_topo$test$moran.i) > 0.1) { # If sample has autocorrelation...
print('Sample exhibits spatial autocorrelation. Trying again with a new sample') # Provide a message.
Map_valindices_sampler(Num) } else { # Recursively try again with a new sample. Otherwise...
return(Samp) }} # Return the sample with minimal spatial autocorrelation.
Map_valindices_samp <- Map_valindices_sampler(1000) # Apply the above function to obtain a proper sample of pixels.
Map_valindices_sampler <- function(Num) { # Function to sample spatially-unautocorrelated pixels from "Map_valindices".
Samp <- sample(Map_valindices, Num) # Randomly sample "Num" raster pixel indices from "Map_valindices".
Coordinates <- xyFromCell(Map_hab, cell = Samp) # Get the lon/lat coordinates of the raster pixels in the sample.
Distance_matrix <- pointDistance(Coordinates, lonlat = TRUE) # Produce matrix of distances between the sample pixels.
Distance_matrix[upper.tri(Distance_matrix)] <- t(Distance_matrix)[upper.tri(Distance_matrix)] # Make matrix full.
Moran_hab <- moran(x = Map_hab[Samp], distance.matrix = Distance_matrix, verbose = FALSE) # Moran's I for hab.
Moran_topo <- moran(x = Map_topo[Samp], distance.matrix = Distance_matrix, verbose = FALSE) # Moran's I for topo.
if (abs(Moran_hab$test$moran.i) > 0.15 | abs(Moran_topo$test$moran.i) > 0.15) { # If sample has autocorrelation...
print('Sample exhibits spatial autocorrelation. Trying again with a new sample') # Provide a message.
Map_valindices_sampler(Num) } else { # Recursively try again with a new sample. Otherwise...
return(Samp) }} # Return the sample with minimal spatial autocorrelation.
Map_valindices_samp <- Map_valindices_sampler(1000) # Apply the above function to obtain a proper sample of pixels.
library(ggplot2) # For making plot visualizations.
Map_df <- data.frame(Hab = values(Map_hab)[Map_valindices_samp], Topo = values(Map_topo)[Map_valindices_samp],
Lat = abs(xyFromCell(Map_hab, Map_valindices_samp)[,2])) # Data frame with variables for the plots below.
ggplot(Map_df, aes(Hab, Topo)) + # Select data for baseline plot of habitat vs. topographic heterogeneity values.
geom_point(size = 3) + geom_smooth(method = 'lm', col = 'deepskyblue3', lwd = 3) + # Scatterplot w/ regression line.
labs(x = 'Habitat Heterogeneity', y = 'Topographic Heterogeneity') + # Set axis labels.
coord_cartesian(xlim = c(-6, -1), ylim = c(-1, 5)) + # Set axis range limits.
scale_x_continuous(labels = function(Lab) { sprintf('%.1f', Lab) }) + # Set X axis tick labels to have one decimal.
scale_y_continuous(labels = function(Lab) { sprintf('%.1f', Lab) }) + # Set Y axis tick labels to have one decimal.
theme_classic() + # Make the plot have a classic-looking theme.
theme(axis.text = element_text(size = 40), axis.text.x = element_text(hjust = 0.8), axis.title = element_text(
size = 40), axis.title.x = element_text(margin = margin(t = 20)), axis.title.y = element_text(margin = margin(
r = 25))) # Format axes.
Map_df$Resids <- lm(Map_df$Topo ~ Map_df$Hab)$residuals # Add column of residuals of plot above to "Map_df".
ggplot(Map_df, aes(Lat, Resids)) + # Select data for plot of residuals vs. abs latitude to assess latitude's affect.
geom_point(size = 3) + geom_smooth(method = 'loess', col = 'deepskyblue3', lwd = 3) + # Scatterplot with LOESS curve.
geom_hline(yintercept = 0, col = 'darkgoldenrod3', lty = 1, size = 2) + # Add horizontal line at Y = 0.
labs(x = 'Latitude (abs Degrees)', y = 'Residuals') + # Set axis labels.
coord_cartesian(xlim = c(0, 38), ylim = c(-2, 3.5)) + # Set axis range limits.
scale_x_continuous(labels = function(Lab) { sprintf('%.1f', Lab) }) + # Set X axis tick labels to have one decimal.
scale_y_continuous(labels = function(Lab) { sprintf('%.1f', Lab) }) + # Set Y axis tick labels to have one decimal.
theme_classic() + # Make the plot have a classic-looking theme.
theme(axis.text = element_text(size = 40), axis.title = element_text(size = 40), axis.title.x = element_text(
margin = margin(t = 20))) # Format axes.
HeteroCor <- cor(Map_df$Hab, Map_df$Topo, method = 'spearman') # Hab vs. topo correlation.
ResidsCor <- cor(Map_df$Lat, Map_df$Resids, method = 'spearman') # Resids vs. lat correlation.
cor(Map_df$Hab, Map_df$Topo, method = 'pearson')^2 # Hab vs. topo correlation.
Map_hab <- raster('cv_01_05_1km_uint16.tif') # Habitat heterogeneity map at 1-km resolution.
Map_topo <- raster('tri_1KMmn_GMTEDmd.tif') # Topographic heterogeneity map at 1-km resolution.
for (Het_map in c('Map_hab', 'Map_topo')) { # For each map...
Map <- eval(parse(text = Het_map)) # Create a variable, "Map", the is equal to the current map.
Map <- crop(Map, Africa) # Crop the map to the extent of "Africa".
Map <- mask(Map, Africa) # Mask the cropped map to the shape of "Africa".
Map <- Map * ifelse(grepl('hab', Het_map), 0.0001, 1) # Multiply the "hab" map by 0.0001 based on EarthEnv metadata.
Map <- log(Map); values(Map)[is.infinite(values(Map))] <- NA # Log-transform map values and remove resultant Inf.
Map <- raster::aggregate(Map, 50) # Potentially aggregate map to a coarser resolution.
assign(Het_map, Map) }; rm(Het_map, Map) # Update the map to be equal to "Map", now that "Map" is processed.
Map_valindices <- which(!is.na(values(Map_hab)) & !is.na(values(Map_topo))) # Map pixel indices with paired values.
library(spatialRF) # For assessing spatial autocorrelation and using the "moran" function.
Map_valindices_sampler <- function(Num) { # Function to sample spatially-unautocorrelated pixels from "Map_valindices".
Samp <- sample(Map_valindices, Num) # Randomly sample "Num" raster pixel indices from "Map_valindices".
Coordinates <- xyFromCell(Map_hab, cell = Samp) # Get the lon/lat coordinates of the raster pixels in the sample.
Distance_matrix <- pointDistance(Coordinates, lonlat = TRUE) # Produce matrix of distances between the sample pixels.
Distance_matrix[upper.tri(Distance_matrix)] <- t(Distance_matrix)[upper.tri(Distance_matrix)] # Make matrix full.
Moran_hab <- moran(x = Map_hab[Samp], distance.matrix = Distance_matrix, verbose = FALSE) # Moran's I for hab.
Moran_topo <- moran(x = Map_topo[Samp], distance.matrix = Distance_matrix, verbose = FALSE) # Moran's I for topo.
if (abs(Moran_hab$test$moran.i) > 0.15 | abs(Moran_topo$test$moran.i) > 0.15) { # If sample has autocorrelation...
print('Sample exhibits spatial autocorrelation. Trying again with a new sample') # Provide a message.
Map_valindices_sampler(Num) } else { # Recursively try again with a new sample. Otherwise...
return(Samp) }} # Return the sample with minimal spatial autocorrelation.
Map_valindices_samp <- Map_valindices_sampler(1000) # Apply the above function to obtain a proper sample of pixels.
library(ggplot2) # For making plot visualizations.
Map_df <- data.frame(Hab = values(Map_hab)[Map_valindices_samp], Topo = values(Map_topo)[Map_valindices_samp],
Lat = abs(xyFromCell(Map_hab, Map_valindices_samp)[,2])) # Data frame with variables for the plots below.
ggplot(Map_df, aes(Hab, Topo)) + # Select data for baseline plot of habitat vs. topographic heterogeneity values.
geom_point(size = 3) + geom_smooth(method = 'lm', col = 'deepskyblue3', lwd = 3) + # Scatterplot w/ regression line.
labs(x = 'Habitat Heterogeneity', y = 'Topographic Heterogeneity') + # Set axis labels.
coord_cartesian(xlim = c(-6, -1), ylim = c(-1, 5)) + # Set axis range limits.
scale_x_continuous(labels = function(Lab) { sprintf('%.1f', Lab) }) + # Set X axis tick labels to have one decimal.
scale_y_continuous(labels = function(Lab) { sprintf('%.1f', Lab) }) + # Set Y axis tick labels to have one decimal.
theme_classic() + # Make the plot have a classic-looking theme.
theme(axis.text = element_text(size = 40), axis.text.x = element_text(hjust = 0.8), axis.title = element_text(
size = 40), axis.title.x = element_text(margin = margin(t = 20)), axis.title.y = element_text(margin = margin(
r = 25))) # Format axes.
Map_df$Resids <- lm(Map_df$Topo ~ Map_df$Hab)$residuals # Add column of residuals of plot above to "Map_df".
ggplot(Map_df, aes(Lat, Resids)) + # Select data for plot of residuals vs. abs latitude to assess latitude's affect.
geom_point(size = 3) + geom_smooth(method = 'loess', col = 'deepskyblue3', lwd = 3) + # Scatterplot with LOESS curve.
geom_hline(yintercept = 0, col = 'darkgoldenrod3', lty = 1, size = 2) + # Add horizontal line at Y = 0.
labs(x = 'Latitude (abs Degrees)', y = 'Residuals') + # Set axis labels.
coord_cartesian(xlim = c(0, 38), ylim = c(-2, 3.5)) + # Set axis range limits.
scale_x_continuous(labels = function(Lab) { sprintf('%.1f', Lab) }) + # Set X axis tick labels to have one decimal.
scale_y_continuous(labels = function(Lab) { sprintf('%.1f', Lab) }) + # Set Y axis tick labels to have one decimal.
theme_classic() + # Make the plot have a classic-looking theme.
theme(axis.text = element_text(size = 40), axis.title = element_text(size = 40), axis.title.x = element_text(
margin = margin(t = 20))) # Format axes.
HeteroCor <- cor(Map_df$Hab, Map_df$Topo, method = 'spearman') # Hab vs. topo correlation.
Map_valindices <- which(!is.na(values(Map_hab)) & !is.na(values(Map_topo))) # Map pixel indices with paired values.
library(spatialRF) # For assessing spatial autocorrelation and using the "moran" function.
Map_valindices_samp <- Map_valindices_sampler(1000) # Apply the above function to obtain a proper sample of pixels.
library(ggplot2) # For making plot visualizations.
Map_df <- data.frame(Hab = values(Map_hab)[Map_valindices_samp], Topo = values(Map_topo)[Map_valindices_samp],
Lat = abs(xyFromCell(Map_hab, Map_valindices_samp)[,2])) # Data frame with variables for the plots below.
ggplot(Map_df, aes(Hab, Topo)) + # Select data for baseline plot of habitat vs. topographic heterogeneity values.
geom_point(size = 3) + geom_smooth(method = 'lm', col = 'deepskyblue3', lwd = 3) + # Scatterplot w/ regression line.
labs(x = 'Habitat Heterogeneity', y = 'Topographic Heterogeneity') + # Set axis labels.
coord_cartesian(xlim = c(-6, -1), ylim = c(-1, 5)) + # Set axis range limits.
scale_x_continuous(labels = function(Lab) { sprintf('%.1f', Lab) }) + # Set X axis tick labels to have one decimal.
scale_y_continuous(labels = function(Lab) { sprintf('%.1f', Lab) }) + # Set Y axis tick labels to have one decimal.
theme_classic() + # Make the plot have a classic-looking theme.
theme(axis.text = element_text(size = 40), axis.text.x = element_text(hjust = 0.8), axis.title = element_text(
size = 40), axis.title.x = element_text(margin = margin(t = 20)), axis.title.y = element_text(margin = margin(
r = 25))) # Format axes.
HeteroCor <- cor(Map_df$Hab, Map_df$Topo, method = 'spearman') # Hab vs. topo correlation.
Map_valindices_samp <- Map_valindices_sampler(1000) # Apply the above function to obtain a proper sample of pixels.
Map_df <- data.frame(Hab = values(Map_hab)[Map_valindices_samp], Topo = values(Map_topo)[Map_valindices_samp],
Lat = abs(xyFromCell(Map_hab, Map_valindices_samp)[,2])) # Data frame with variables for the plots below.
ggplot(Map_df, aes(Hab, Topo)) + # Select data for baseline plot of habitat vs. topographic heterogeneity values.
geom_point(size = 3) + geom_smooth(method = 'lm', col = 'deepskyblue3', lwd = 3) + # Scatterplot w/ regression line.
labs(x = 'Habitat Heterogeneity', y = 'Topographic Heterogeneity') + # Set axis labels.
coord_cartesian(xlim = c(-6, -1), ylim = c(-1, 5)) + # Set axis range limits.
scale_x_continuous(labels = function(Lab) { sprintf('%.1f', Lab) }) + # Set X axis tick labels to have one decimal.
scale_y_continuous(labels = function(Lab) { sprintf('%.1f', Lab) }) + # Set Y axis tick labels to have one decimal.
theme_classic() + # Make the plot have a classic-looking theme.
theme(axis.text = element_text(size = 40), axis.text.x = element_text(hjust = 0.8), axis.title = element_text(
size = 40), axis.title.x = element_text(margin = margin(t = 20)), axis.title.y = element_text(margin = margin(
r = 25))) # Format axes.
HeteroCor <- cor(Map_df$Hab, Map_df$Topo, method = 'spearman') # Hab vs. topo correlation.
Map_df$Resids <- lm(Map_df$Topo ~ Map_df$Hab)$residuals # Add column of residuals of plot above to "Map_df".
ggplot(Map_df, aes(Lat, Resids)) + # Select data for plot of residuals vs. abs latitude to assess latitude's affect.
geom_point(size = 3) + geom_smooth(method = 'loess', col = 'deepskyblue3', lwd = 3) + # Scatterplot with LOESS curve.
geom_hline(yintercept = 0, col = 'darkgoldenrod3', lty = 1, size = 2) + # Add horizontal line at Y = 0.
labs(x = 'Latitude (abs Degrees)', y = 'Residuals') + # Set axis labels.
coord_cartesian(xlim = c(0, 38), ylim = c(-2, 3.5)) + # Set axis range limits.
scale_x_continuous(labels = function(Lab) { sprintf('%.1f', Lab) }) + # Set X axis tick labels to have one decimal.
scale_y_continuous(labels = function(Lab) { sprintf('%.1f', Lab) }) + # Set Y axis tick labels to have one decimal.
theme_classic() + # Make the plot have a classic-looking theme.
theme(axis.text = element_text(size = 40), axis.title = element_text(size = 40), axis.title.x = element_text(
margin = margin(t = 20))) # Format axes.
HeteroCor <- cor(Map_df$Hab, Map_df$Topo, method = 'spearman') # Hab vs. topo correlation.
cor(Map_df$Hab, Map_df$Topo, method = 'pearson')^2 # Hab vs. topo correlation.
Map_hab <- raster('cv_01_05_1km_uint16.tif') # Habitat heterogeneity map at 1-km resolution.
Map_topo <- raster('tri_1KMmn_GMTEDmd.tif') # Topographic heterogeneity map at 1-km resolution.
for (Het_map in c('Map_hab', 'Map_topo')) { # For each map...
Map <- eval(parse(text = Het_map)) # Create a variable, "Map", the is equal to the current map.
Map <- crop(Map, Africa) # Crop the map to the extent of "Africa".
Map <- mask(Map, Africa) # Mask the cropped map to the shape of "Africa".
Map <- Map * ifelse(grepl('hab', Het_map), 0.0001, 1) # Multiply the "hab" map by 0.0001 based on EarthEnv metadata.
Map <- log(Map); values(Map)[is.infinite(values(Map))] <- NA # Log-transform map values and remove resultant Inf.
# Map <- raster::aggregate(Map, 50) # Potentially aggregate map to a coarser resolution.
assign(Het_map, Map) }; rm(Het_map, Map) # Update the map to be equal to "Map", now that "Map" is processed.
Map_valindices <- which(!is.na(values(Map_hab)) & !is.na(values(Map_topo))) # Map pixel indices with paired values.
library(spatialRF) # For assessing spatial autocorrelation and using the "moran" function.
Map_valindices_sampler <- function(Num) { # Function to sample spatially-unautocorrelated pixels from "Map_valindices".
Samp <- sample(Map_valindices, Num) # Randomly sample "Num" raster pixel indices from "Map_valindices".
Coordinates <- xyFromCell(Map_hab, cell = Samp) # Get the lon/lat coordinates of the raster pixels in the sample.
Distance_matrix <- pointDistance(Coordinates, lonlat = TRUE) # Produce matrix of distances between the sample pixels.
Distance_matrix[upper.tri(Distance_matrix)] <- t(Distance_matrix)[upper.tri(Distance_matrix)] # Make matrix full.
Moran_hab <- moran(x = Map_hab[Samp], distance.matrix = Distance_matrix, verbose = FALSE) # Moran's I for hab.
Moran_topo <- moran(x = Map_topo[Samp], distance.matrix = Distance_matrix, verbose = FALSE) # Moran's I for topo.
if (abs(Moran_hab$test$moran.i) > 0.1 | abs(Moran_topo$test$moran.i) > 0.1) { # If sample has autocorrelation...
print('Sample exhibits spatial autocorrelation. Trying again with a new sample') # Provide a message.
Map_valindices_sampler(Num) } else { # Recursively try again with a new sample. Otherwise...
return(Samp) }} # Return the sample with minimal spatial autocorrelation.
Map_valindices_samp <- Map_valindices_sampler(1000) # Apply the above function to obtain a proper sample of pixels.
library(ggplot2) # For making plot visualizations.
Map_df <- data.frame(Hab = values(Map_hab)[Map_valindices_samp], Topo = values(Map_topo)[Map_valindices_samp],
Lat = abs(xyFromCell(Map_hab, Map_valindices_samp)[,2])) # Data frame with variables for the plots below.
ggplot(Map_df, aes(Hab, Topo)) + # Select data for baseline plot of habitat vs. topographic heterogeneity values.
geom_point(size = 3) + geom_smooth(method = 'lm', col = 'deepskyblue3', lwd = 3) + # Scatterplot w/ regression line.
labs(x = 'Habitat Heterogeneity', y = 'Topographic Heterogeneity') + # Set axis labels.
coord_cartesian(xlim = c(-6, -1), ylim = c(-1, 5)) + # Set axis range limits.
scale_x_continuous(labels = function(Lab) { sprintf('%.1f', Lab) }) + # Set X axis tick labels to have one decimal.
scale_y_continuous(labels = function(Lab) { sprintf('%.1f', Lab) }) + # Set Y axis tick labels to have one decimal.
theme_classic() + # Make the plot have a classic-looking theme.
theme(axis.text = element_text(size = 40), axis.text.x = element_text(hjust = 0.8), axis.title = element_text(
size = 40), axis.title.x = element_text(margin = margin(t = 20)), axis.title.y = element_text(margin = margin(
r = 25))) # Format axes.
Map_df$Resids <- lm(Map_df$Topo ~ Map_df$Hab)$residuals # Add column of residuals of plot above to "Map_df".
ggplot(Map_df, aes(Lat, Resids)) + # Select data for plot of residuals vs. abs latitude to assess latitude's affect.
geom_point(size = 3) + geom_smooth(method = 'loess', col = 'deepskyblue3', lwd = 3) + # Scatterplot with LOESS curve.
geom_hline(yintercept = 0, col = 'darkgoldenrod3', lty = 1, size = 2) + # Add horizontal line at Y = 0.
labs(x = 'Latitude (abs Degrees)', y = 'Residuals') + # Set axis labels.
coord_cartesian(xlim = c(0, 38), ylim = c(-2, 3.5)) + # Set axis range limits.
scale_x_continuous(labels = function(Lab) { sprintf('%.1f', Lab) }) + # Set X axis tick labels to have one decimal.
scale_y_continuous(labels = function(Lab) { sprintf('%.1f', Lab) }) + # Set Y axis tick labels to have one decimal.
theme_classic() + # Make the plot have a classic-looking theme.
theme(axis.text = element_text(size = 40), axis.title = element_text(size = 40), axis.title.x = element_text(
margin = margin(t = 20))) # Format axes.
Map_valindices_samp <- Map_valindices_sampler(1000) # Apply the above function to obtain a proper sample of pixels.
library(ggplot2) # For making plot visualizations.
Map_df <- data.frame(Hab = values(Map_hab)[Map_valindices_samp], Topo = values(Map_topo)[Map_valindices_samp],
Lat = abs(xyFromCell(Map_hab, Map_valindices_samp)[,2])) # Data frame with variables for the plots below.
ggplot(Map_df, aes(Hab, Topo)) + # Select data for baseline plot of habitat vs. topographic heterogeneity values.
geom_point(size = 3) + geom_smooth(method = 'lm', col = 'deepskyblue3', lwd = 3) + # Scatterplot w/ regression line.
labs(x = 'Habitat Heterogeneity', y = 'Topographic Heterogeneity') + # Set axis labels.
coord_cartesian(xlim = c(-6, -1), ylim = c(-1, 5)) + # Set axis range limits.
scale_x_continuous(labels = function(Lab) { sprintf('%.1f', Lab) }) + # Set X axis tick labels to have one decimal.
scale_y_continuous(labels = function(Lab) { sprintf('%.1f', Lab) }) + # Set Y axis tick labels to have one decimal.
theme_classic() + # Make the plot have a classic-looking theme.
theme(axis.text = element_text(size = 40), axis.text.x = element_text(hjust = 0.8), axis.title = element_text(
size = 40), axis.title.x = element_text(margin = margin(t = 20)), axis.title.y = element_text(margin = margin(
r = 25))) # Format axes.
Map_df$Resids <- lm(Map_df$Topo ~ Map_df$Hab)$residuals # Add column of residuals of plot above to "Map_df".
ggplot(Map_df, aes(Lat, Resids)) + # Select data for plot of residuals vs. abs latitude to assess latitude's affect.
geom_point(size = 3) + geom_smooth(method = 'loess', col = 'deepskyblue3', lwd = 3) + # Scatterplot with LOESS curve.
geom_hline(yintercept = 0, col = 'darkgoldenrod3', lty = 1, size = 2) + # Add horizontal line at Y = 0.
labs(x = 'Latitude (abs Degrees)', y = 'Residuals') + # Set axis labels.
coord_cartesian(xlim = c(0, 38), ylim = c(-2, 3.5)) + # Set axis range limits.
scale_x_continuous(labels = function(Lab) { sprintf('%.1f', Lab) }) + # Set X axis tick labels to have one decimal.
scale_y_continuous(labels = function(Lab) { sprintf('%.1f', Lab) }) + # Set Y axis tick labels to have one decimal.
theme_classic() + # Make the plot have a classic-looking theme.
theme(axis.text = element_text(size = 40), axis.title = element_text(size = 40), axis.title.x = element_text(
margin = margin(t = 20))) # Format axes.
Map_valindices_samp <- Map_valindices_sampler(1000) # Apply the above function to obtain a proper sample of pixels.
library(ggplot2) # For making plot visualizations.
Map_df <- data.frame(Hab = values(Map_hab)[Map_valindices_samp], Topo = values(Map_topo)[Map_valindices_samp],
Lat = abs(xyFromCell(Map_hab, Map_valindices_samp)[,2])) # Data frame with variables for the plots below.
ggplot(Map_df, aes(Hab, Topo)) + # Select data for baseline plot of habitat vs. topographic heterogeneity values.
geom_point(size = 3) + geom_smooth(method = 'lm', col = 'deepskyblue3', lwd = 3) + # Scatterplot w/ regression line.
labs(x = 'Habitat Heterogeneity', y = 'Topographic Heterogeneity') + # Set axis labels.
coord_cartesian(xlim = c(-6, -1), ylim = c(-1, 5)) + # Set axis range limits.
scale_x_continuous(labels = function(Lab) { sprintf('%.1f', Lab) }) + # Set X axis tick labels to have one decimal.
scale_y_continuous(labels = function(Lab) { sprintf('%.1f', Lab) }) + # Set Y axis tick labels to have one decimal.
theme_classic() + # Make the plot have a classic-looking theme.
theme(axis.text = element_text(size = 40), axis.text.x = element_text(hjust = 0.8), axis.title = element_text(
size = 40), axis.title.x = element_text(margin = margin(t = 20)), axis.title.y = element_text(margin = margin(
r = 25))) # Format axes.
Map_df$Resids <- lm(Map_df$Topo ~ Map_df$Hab)$residuals # Add column of residuals of plot above to "Map_df".
ggplot(Map_df, aes(Lat, Resids)) + # Select data for plot of residuals vs. abs latitude to assess latitude's affect.
geom_point(size = 3) + geom_smooth(method = 'loess', col = 'deepskyblue3', lwd = 3) + # Scatterplot with LOESS curve.
geom_hline(yintercept = 0, col = 'darkgoldenrod3', lty = 1, size = 2) + # Add horizontal line at Y = 0.
labs(x = 'Latitude (abs Degrees)', y = 'Residuals') + # Set axis labels.
coord_cartesian(xlim = c(0, 38), ylim = c(-2, 3.5)) + # Set axis range limits.
scale_x_continuous(labels = function(Lab) { sprintf('%.1f', Lab) }) + # Set X axis tick labels to have one decimal.
scale_y_continuous(labels = function(Lab) { sprintf('%.1f', Lab) }) + # Set Y axis tick labels to have one decimal.
theme_classic() + # Make the plot have a classic-looking theme.
theme(axis.text = element_text(size = 40), axis.title = element_text(size = 40), axis.title.x = element_text(
margin = margin(t = 20))) # Format axes.
HeteroCor_iter <- c() # Vector to hold multiple random iterations of "HeteroCor".
for (Iter in 1:100) { # Repeat the measurement of "HeteroCor" many times to generate a distribution of it...
Samp <- Map_valindices_sampler(1000) # Obtain a proper sample of raster pixels, then run the calculation on them...
HeteroCor_iter[Iter] <- cor(values(Map_hab)[Samp], values(Map_topo)[Samp], method = 'spearman') }; rm(Iter, Samp)
mean(HeteroCor_iter)
sd(HeteroCor_iter)
par(mar = c(7,7,1,1)) # Adjust plot margin settings.
hist(HeteroCor_iter, main = '', xlab = '', ylab = '', cex.axis = 3, col = 'deepskyblue3', breaks = 20) # Cor distrib.
mtext('Correlation Value', side = 1, line = 4, font = 1, cex = 4) # X-axis label.
mtext('Frequency', side = 2, line = 4, font = 1, cex = 4) # Y-axis label.
par(mar = c(7,7,1,1)) # Adjust plot margin settings.
hist(HeteroCor_iter, main = '', xlab = '', ylab = '', cex.axis = 3, mgp = c(3,1.5,0), col = 'deepskyblue3', breaks = 20)
mtext('Correlation Value', side = 1, line = 4, font = 1, cex = 4) # X-axis label.
mtext('Frequency', side = 2, line = 4, font = 1, cex = 4) # Y-axis label.
par(mar = c(7,7,1,1)) # Adjust plot margin settings.
hist(HeteroCor_iter, main = '', xlab = '', ylab = '', cex.axis = 3, mgp = c(3,1.5,0), col = 'deepskyblue3', breaks = 20)
mtext('Correlation Value', side = 1, line = 5, font = 1, cex = 4) # X-axis label.
mtext('Frequency', side = 2, line = 5, font = 1, cex = 4) # Y-axis label.
par(mar = c(7.5,7.5,1,1)) # Adjust plot margin settings.
hist(HeteroCor_iter, main = '', xlab = '', ylab = '', cex.axis = 3, mgp = c(3,1.5,0), col = 'deepskyblue3', breaks = 20)
mtext('Correlation Value', side = 1, line = 5, font = 1, cex = 4) # X-axis label.
mtext('Frequency', side = 2, line = 5, font = 1, cex = 4) # Y-axis label.
par(mar = c(7.5,7.5,1,1)) # Adjust plot margin settings.
hist(HeteroCor_iter, main = '', xlab = '', ylab = '', cex.axis = 2.75, mgp = c(3,1.5,0), col = 'deepskyblue3',
breaks = 20) # Historgram of the values in "Heterocor_iter".
mtext('Correlation Value', side = 1, line = 5, font = 1, cex = 4) # X-axis label.
mtext('Frequency', side = 2, line = 5, font = 1, cex = 4) # Y-axis label.
par(mar = c(7.75,7.75,1,1)) # Adjust plot margin settings.
hist(HeteroCor_iter, main = '', xlab = '', ylab = '', cex.axis = 2.75, mgp = c(3,1.5,0), col = 'deepskyblue3',
breaks = 20) # Historgram of the values in "Heterocor_iter".
mtext('Correlation Value', side = 1, line = 5, font = 1, cex = 4) # X-axis label.
mtext('Frequency', side = 2, line = 5, font = 1, cex = 4) # Y-axis label.
source("~/Downloads/HeterogeneityRangeSize_Code.R", echo=TRUE)
